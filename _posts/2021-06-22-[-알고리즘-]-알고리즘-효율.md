---
categories:
  - 알고리즘
tags:
  - 알고리즘
---
<br>

# 알고리즘
___

컴퓨터 프로그램은 정렬하기(sorting)와 같은 특정 작업을 수행하는 개별 모듈(module)을 모아서 구성하고 프로그램 전체 설계보다 특정 과제를 수행하는 개별 모듈 설계에 중점을 주는데 특정 과제를 문제(problem)라고 한다.

<br>

## 1. 알고리즘

문제를 푸는 단계 별 절차, 문제를 푸는 기법은 다양하지만, 기법에 따라서 알고리즘의 성능은 차이가 날 수 있다. 그러므로 어떤 문제를 어떤 기법으로 풀 것인지, 시간(time)과 공간(space)의 사용량을 기준으로 얼마나 **효율적**인지 분석하는데 관심을 가져야 한다.

※ 시간: 알고리즘을 컴퓨터로 실행 할 때 걸리는 시간의 길이
※ 공간: 필요한 메모리의 크기

<br>


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/884f28d9-fe08-4930-b5af-831f08cb1b33" alt width="100%">
<em>알고리즘 문제</em>
</center>


<br>

- 파라미터(parameter): 문제에서 값이 지정되어 있지 않은 변수
- 입력 사례(instance): 파라미터에 지정할 값
- 리스트(list): 어떤 원소를 특정 순서로 나열해 놓은 것.
- 해답(solution) : 파라미터를 입력 사례로 지정하여 질문한 문제의 해답

<br>


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/51d485fc-b1fb-4903-b357-b0a44975d0f0" alt width="100%">
<em></em>
</center>
<br>

※프로시저: 특정한 로직을 처리하기만 하고 결과 값을 반환하지 않는 서브 프로그램. Function과 같은 기능이나 Function은 리턴값을 강조하는 한편, 프로시저는 중간처리과정 중요시한다.


## 2. 효율적 알고리즘
### 1) 이분 검색, 순차 검색

<br>

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/c9966099-008d-4800-b0c4-5b1984eb410f" alt width=400>
<em>이분 검색, 순차 검색</em>
</center>
<br>

- 이분 검색 : $x$를 찾기 위해 $x$를 배열 정중앙에 위치한 원소와 비교, 같다면 찾았기에 알고리즘을 끝내고, 그 원소보다 작다면 전반부, 크다면 후반부의 정중앙에 위치한 원소와 비교해 이분 검색 절차를 되풀이 하는 방법

- 순차 검색 : 순서대로 원소를 비교함으로써, 리스트에서 찾고자 하는 값을 맨 앞에서부터 끝까지 차례대로 찾아 나가는 검색 방법
<br>

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/919873f6-e065-45eb-84a4-d426ae00de88" alt width=400>
<em>X가 배열의 모든 원소보다 클때 순차검색과 이분검색에서의 비교횟수</em>
</center>

<br>

### 2) 피보나치 수열
<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/708e6c5d-ee99-4e41-b29d-cb98541a1ca0" alt width="100%">
<em>피보나치 수열</em>
</center>

<br>

피보나치 수열의 $n$번째 수는 다음과 같이 재귀로(recursively: 자신을 되부르는 꼴로) 정의. 재귀로 정의하기 때문에 정의를 그대로 재귀 알고리즘으로 바꾸는 것 가능
<br>

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/ae5171ce-1b8d-4d96-a63f-fd1f1b6f13a0" alt width="60%">
<em>알고리즘에 따른 차이</em>
</center>
<br>

## 2. 알고리즘 분석

분석 이론을 적용하면서 단위 연산, 주변 명령문,제어 명령문을 실행하는데 실제 걸리는 시간들을 고려

<br>

### 1) 알고리즘의 단위 연산(basic instruction)

입력 크기를 구한 후 , 어떤 명령문이나 명령문 덩어리(군)를 선정하여 알고리즘이 실행한 총 작업의 양을 이에 실행한 횟수에 대략적으로 비례하도록 함. 그 때의 명령문이나 명령문 군을 칭함.

<br>

### 2) 알고리즘의 시간 복잡도 분석(time complexity analysis)

입력 크기를 기준으로 단위 연산을 몇 번 수행하는지 구함. 제어 구조를 구성하는 명령문은 보통 단위 연산으로 취급X

<br>

- **일정 시간 복잡도**(every-case time complexity) : 실행 횟수가 일정한 경우 $T(n)$을 입력 크기 $n$에 대해서 알고리즘이 단위 연산을 실행하는  횟수로 정의하는데, 여기서 $T(n)$을 칭함
	- 일정 시간 복잡도 분석 : $T(n)$을 구하는 과정

- **최악 시간 복잡도**(worst –case time complexity) : 단위 연산을 수행하는 최대 횟수를 측정 $W(n)$을 입력 크기 $n$에 대해서 알고리즘이 실행할 단위 연산의 최대 횟수로 정의하는데 그때의 $W(n)$ 값
	- 최악 시간 복잡도 분석: $W(n)$을 구하는 과정, $T(n)$값이 존재하면 $W(n) = T(n)$


- **평균 시간 복잡도**(average-case time complexity) : 어떤 알고리즘에 대해 $A(n)$을 입력 크기 $n$에 대해 그 알고리즘이 수행할 단위 연산의 평균 횟수(기대치)로 정의할 때, 그때의  $A(n)$ 값
	- 평균 시간 복잡도 분석: $A(n)$을 구하는 과정 :  $W(n)$과 같이 $T(n)$이 존재하면 $A(n)= T(n)$

- **최선 시간 복잡도**(best-case time complexity analysis) : 어떤 알고리즘에 대해, $B(n)$을 입력 크기 $n$에 대해 그 알고리즘이 실행할 단위 연산의 최소 횟수로 정의할 때 그때의  $B(n)$ 값
	- 최선 시간 복잡도 분석:  $B(n)$을 구하는 과정, $W(n)$과 $A(n)$의 경우와 같이 만약$T(n)$이 존재하면 $B(n)=T(n)$.


메모리(=공간 복잡도(memory complexity)의 분석(알고리즘이 메모리 사용 면으로 얼마나 효율적인지 분석)에도 적용할 수 있으며 **복잡도 함수**(complexity function)는 양의 정수에서 양의 실수(0포함)로 매핑하는 함수로, 특정 알고리즘의 시간 복잡도나 메모리 복잡도를 가리키지 않을 때는 복잡도 함수를 보통 $f(n)$과 $g(n)$같은 표준 함수법으로 표현한다.

<br>

### 3) 명령문(instructions)

**주변 명령문**(overhead instructions) : 루프 이전에 실행되는 초기화문 같은 명령문, 실행 횟수는 일반적으로 입력 크기에 상관없이 항상 일정

**제어 명령문**(control instructions) : 루프를 제어하기 위한 인덱스 증가 명령문 같은 명령문, 실행 횟수는 입력 크기에 비례하여 증가

<br>

## 3. 정확성 분석

알고리즘이 기대한 대로 실행되는지 증명하는 것이다.

<br>

## 4. 차수

첫째 알고리즘의 일정 시간 복잡도는 $100n$, 둘째 알고리즘의 일정 시간 복잡도 $0.01n^2$  이라고 가정했을 때 첫째 알고리즘이 둘째보다 궁극적으로 빠르다. 두 알고리즘에서 설정한 단위 연산 1회 실행 시간이 같고, 주변 명령문 실행 시간도 거의 같은 경우 **n**값에 대해서만 첫째 알고리즘이 빠르다고 할 수 있다.

<br>

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/f02bc4b8-2627-4fe4-ad11-a127ee878ba0" alt width="100%">
<em>1차 시간 알고리즘은 모두 2차 시간 알고리즘보다 궁극적으로 더 빠르다.</em>
</center>

<br>


 - **1차 시간 알고리즘**(linear-time algorithm) : 시간 복잡도가 입력 크기 $n$에 대해 1차 함수 (ex) 시간 복잡도가 $n$과 $100n$인 알고리즘)

- **2차 시간 알고리즘**(quadratic-time algorithm) : 알고리즘 시간 복잡도가 입력 크기 $n$에 대해 2차 함수 (ex) 시간 복잡도가 $1n^2$과 $0.01n^2$인 알고리즘)
	- 순수 2차 함수(pure quadratic function) : 1차항이 없는 $5n^2$ 과 $5n^2 +100$ 
	- 완전 2차 함수(complete quadratifuction) : 1차항이 있는  $0.1n^2  + n +100$ 


 - $Θ$ : 쎄타(theta), 순수 함수로 분류되는 복잡도 함수의 집합
	- 어떤 함수가 $Θ(n^2  )$ 집합의 원소라면 그 함수의 차수가 $n^2$ ,낮은 차수의 항은 버릴 수 있으므로, $g(n)$의 차수는 $n^2$이다.
	- 어떤 알고리즘의 시간 복잡도가 $Θ(n^2  )$에 속하면 그 알고리즘을 2차 시간 알고리즘 또는 $Θ(n^2  )$ 알고리즘이라고 한다.(“그 알고리즘은 $Θ(n^2  )$이다.”)
	- 순수 3차 함수로 분류될 수 있는 복잡도 함수의 집합은 $Θ(n^3  )$이고, 이 집합의 함수는 차수가 $n^3$ 이다.(2차 함수와 비슷하게 정의) 


- **복잡도 카테고리**(complexity categories) : 시간 복잡도의 최고차항의 상수를 무시하고 표시하는 것.

<br>


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/bdbf7d50-9785-42b1-8ca7-f44b8bef59ed" alt width="80%">
<em>차수에 따른 시간 복잡도</em>
</center>


<br>

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/ed75cb3b-201b-422b-aa8b-7cb852f35d3e" alt width="70%">
<em>차수에 따른 시간 복잡도</em>
</center>

<br>

### 1) 큰 O (big O)

주어진 복잡도 함수 f(n)에 대해서 O(f(n))은 정수 N 이상의 모든 n에 대해서 다음 부등식이 성립하는 양의 실수 c와 음이 아닌 정수 N이 존재하는 복잡도 함수 g(n)의 집합이다.  
=> g(n) ≤ 𝐶×𝑓(𝑛)


"g(n)"∈"O(f(n))" 이면 “g(n)은 f(n)의 큰 O이다.”

g(n)이 O(n^2  )이면, g(n)은 궁극적으로 그래프 상에서 어떤 순수2차함수 cn^2  아래 놓이게 된다.

만약 g(n)이 어떤 알고리즘의 시간복잡도라면, 그 알고리즘의 실행시간은 궁극적으로 빠르기가 최소한 2차함수만큼은 된다는 뜻이며, 분석에 사용할 때 g(n)은 궁극적으로 최소한 순수2차함수만큼 좋다라고 할 수 있다.

“큰 O”는 함수의 궁극적인 상태만 고려하기 때문에 함수의 점근적인(asymptotic) 상태를 나타낸다고하며, 함수의 점근적인 상한(asymptotic upper bound)을 정한다라고 한다.

복잡도 함수가 O(n^2  )에 속하기 위해 굳이 2차함수 일 필요가 없으며, 그래프 상에서 궁극적으로 순수2차함수 아래에 놓이기만 하면 된다. -> 어떤 대수(logarithm)함수나 1차함수도 O(n^2  )에 속한다.


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/62121d6d-9ca3-4ea3-9ee4-aaece8942458" alt width="40%">
<em></em>
</center>


### 1) Ω 오메가(omega)


주어진 복잡도 f(n)에 대해서 Ω(f(n))은 N이상의 모든 n에 대해서 다음 부등식을 만족하는 양의 실수 c와 음이 아닌 정수 N이 존재하는 복잡도 함수 g(n)의 집합이다. => g(n)≥ C×f(n)

점근적인 하한(asymptotic lower bound)을 정한다.

"g(n)"∈"Ω(f(n)" 이면, “g(n)은 f(n)의 오메가이다.”

g(n)이 "Ω"(n^2  )에 속하면 g(n)은 궁극적으로 그래프 상에서 어떤 순수2차함수 위에 놓이게 된다.

즉, g(n)은 “궁극적으로 최소한 순수2차함수만큼은 나쁘다.”

어떤 함수가 O(n^2  )와 "Ω"(n^2  ) 모두 속한다면, 궁극적으로 이 함수는 그래프에서 어떤 순수2차함수 아래에 위치하게 됨과 동시에 또다른 어떤 순수2차함수만큼 좋고, 또다른 어떤 순수2차함수만큼 나쁘다.

<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/c4361e9e-1e23-4ec5-8c18-e69ae2d950a3" alt width="40%">
<em></em>
</center>


### 1) 차수(order)

주어진 복잡도 f(n)에 대해서 Θ(f(n)) = O(f(n)) ∩"Ω"(f(n))라 정의하며, Θ(f(n))는 N이상의 모든 정수 n에 대해서 다음 부등식이 만족하는 양의 실수 c, d와 음이 아닌 정수 N이 존재하는 복잡도 함수 g(n)의 집합이다. => c ×f(n) ≤ "g(n)" ≤d×f(n)


"g(n)"∈"O(f(n))" 이면 “g(n)은 f(n)의 차수(order)이다.”


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/4be6f2f7-28e5-480a-a092-921f3b8c3e10" alt width="80%">
<em></em>
</center>


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/dda83566-05b3-42ac-8924-5b685770b32d" alt width="40%">
<em></em>
</center>



작은 o(small o)

주어진 복잡도 함수 f(n)에 대해서 o(f(n))은 모든 양의 실수 c에 대해서 n ≥ N을 만족하는 모든 n에 대해서 다음 부등식을 만족하는 음이 아닌 정수 N이 존재하는 모든 복잡도 함수 g(n)의 집합이다.  => g(n) ≤c×f(n)

"g(n)"∈"o(f(n))" 이면 “g(n)은 f(n)의 작은 o(small o)이다.”

“큰 오(big O)”는 그 범위가 성립하는 “어떤” 양의 실수 c 가 반드시 존재한다는 것을 의미

위의 정의는 “모든“ 양의 실수 c에 대해서 그 범위가 성립해야 하며, 범위가 모든 양수 c에 대해 성립하므로, 임의로 작은 c에 대해 성립한다.

g(n)∈o(f(n)이면, n ≥ N을 만족하는 모든 n에 대해서 다음 부등식을 만족하는 N이 존재한다면, n ≥ N을 만족하는 모든 n에 대해서 "g(n)" ≤0.00001×f(n)을 만족하는 N이 존재한다.

n이 커지게 되면, g(n)은 f(n)에 비해 하찮을 만큼 작아지게 되며, 분석의 관점에서 g(n)이 o(f(n))이면, g(n)은 f(n) 같은 함수보다 궁극적으로 좋다.


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/58e7415c-f846-49e4-bdbf-416223def0b0" alt width="100%">
<em></em>
</center>

실제로는 특성을 반복 적용하는 대신, 낮은 차수를 가진 항을 그냥 버리면 된다고 단순히 생각하면 쉽다.

만약 알고리즘의 정확한 시간복잡도를 구할 수 있다면, 단순히 낮은 차수를 버려서 차수를 결정할 수 있다. 정확한 차수를 구할 수 없을 때는, “큰 오＂나 “오메가“를 쓴다.

어떤 알고리즘의 T(n)[ W(n) 또는 A(n) 또는 B(n)]을 정확하게 결정할 수 없다고 가정했을 때 정의를 바로 적용하여 T(n)∈O(f(n))은 T(n) ∈ Ω(f(n))과 서로 필요충분조건이라는 것을 증명할 수 있다면, T(n) ∈ Θ(f(n))이다.

복잡도를 f(n)∈ Θ(n^2) 대신 f(n) = Θ(n^2) , f(n)= O(n^2) 대신, f(n) = O(n^2) 으로도 표현할 수 있다.


1.4.3 극한을 사용하여 차수를 결정하기

차수를 결정하는데 극한(limit)을 사용할 수도 있는데 이를 위해선 극한과 미분에 대한 이해 필요


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/1df13ca0-00bb-4411-a314-13850ad14a5e" alt width="60%">
<em></em>
</center>


로피탈의 규칙(L’Hopital’s Rule)


<center><img src="https://github.com/limbsoo/limbsoo.github.io/assets/96706760/16c15986-6d22-44c6-bc07-56fa59dfe59a" alt width="100%">
<em></em>
</center>











출처: 알고리즘 기초